
@article{lehmann_everything_2020,
	title = {Everything {Old} is {New} {Again}: {Binary} {Security} of {WebAssembly}},
	abstract = {WebAssembly is an increasingly popular compilation target designed to run code in browsers and on other platforms safely and securely, by strictly separating code and data, enforcing types, and limiting indirect control ﬂow. Still, vulnerabilities in memory-unsafe source languages can translate to vulnerabilities in WebAssembly binaries. In this paper, we analyze to what extent vulnerabilities are exploitable in WebAssembly binaries, and how this compares to native code. We ﬁnd that many classic vulnerabilities which, due to common mitigations, are no longer exploitable in native binaries, are completely exposed in WebAssembly. Moreover, WebAssembly enables unique attacks, such as overwriting supposedly constant data or manipulating the heap using a stack overﬂow. We present a set of attack primitives that enable an attacker (i) to write arbitrary memory, (ii) to overwrite sensitive data, and (iii) to trigger unexpected behavior by diverting control ﬂow or manipulating the host environment. We provide a set of vulnerable proof-of-concept applications along with complete end-to-end exploits, which cover three WebAssembly platforms. An empirical risk assessment on real-world binaries and SPEC CPU programs compiled to WebAssembly shows that our attack primitives are likely to be feasible in practice. Overall, our ﬁndings show a perhaps surprising lack of binary security in WebAssembly. We discuss potential protection mechanisms to mitigate the resulting risks.},
	language = {en},
	journal = {Proceedings of the  29th USENIX Security Symposium},
	author = {Lehmann, Daniel and Kinder, Johannes and Pradel, Michael},
	month = aug,
	year = {2020},
	pages = {217--234},
	file = {Lehmann et al. - Everything Old is New Again Binary Security of We.pdf:C\:\\Users\\holge\\Zotero\\storage\\UX5K75Z6\\Lehmann et al. - Everything Old is New Again Binary Security of We.pdf:application/pdf},
}

@misc{mcfadden_security_2018,
	title = {Security {Chasms} of {WASM}},
	abstract = {WebAssembly is a new technology that allows web developers to run native C/C++
on a webpage with near-native performance. This paper provides a basic introduction to WebAssembly and examines the security risks that a developer may take on by
using it. We cover several examples exploring the theoretical security implications of
WebAssembly. We also cover Emscripten, which is currently the most popular WebAssembly compiler toolchain. Our assessment of Emscripten includes its implementation of compiler-and-linker-level exploit mitigations as well as the internal hardening of its libc implementation, and how its augmentation of WASM introduces new
attack vectors and methods of exploitation. We also provide examples of memory
corruption exploits in the Wasm environment. Under certain circumstances, these
exploits could lead to to hijacking control flow or even executing arbitrary JavaScript
within the context of the web page. Finally, we provide a basic outline of best practices and security considerations for developers wishing to integrate WebAssembly
into their product},
	publisher = {NCC Group},
	author = {McFadden, Brian and Lukasiewicz, Tyler and Dileo, Jeff and Engler, Justin},
	month = aug,
	year = {2018},
	file = {Security Chasms of WASM:C\:\\Users\\holge\\Zotero\\storage\\ARGMSIL2\\us-18-Lukasiewicz-WebAssembly-A-New-World-of-Native_Exploits-On-The-Web-wp.pdf:application/pdf},
}


@article{hilbig_empirical_2021,
	title = {An {Empirical} {Study} of {Real}-{World} {WebAssembly} {Binaries}},
	abstract = {WebAssembly has emerged as a low-level language for the web and beyond. Despite its popularity in different domains, little is known about WebAssembly binaries that occur in the wild. This paper presents a comprehensive empirical study of 8,461 unique WebAssembly binaries gathered from a wide range of sources, including source code repositories, package managers, and live websites. We study the security properties, source languages, and use cases of the binaries and how they influence the security of the WebAssembly ecosystem. Our findings update some previously held assumptions about real-world WebAssembly and highlight problems that call for future research. For example, we show that vulnerabilities that propagate from insecure source languages potentially affect a wide range of binaries (e.g., two thirds of the binaries are compiled from memory unsafe languages, such as C and C++) and that 21\% of all binaries import potentially dangerous APIs from their host environment. We also show that cryptomining, which once accounted for the majority of all WebAssembly code, has been marginalized (less than 1\% of all binaries found on the web) and gives way to a diverse set of use cases. Finally, 29\% of all binaries on the web are minified, calling for techniques to decompile and reverse engineer WebAssembly. Overall, our results show that WebAssembly has left its infancy and is growing up into a language that powers a diverse ecosystem, with new challenges and opportunities for security researchers and practitioners. Besides these insights, we also share the dataset underlying our study, which is 58 times larger than the largest previously reported benchmark.},
	language = {en},
	author = {Hilbig, Aaron and Lehmann, Daniel and Pradel, Michael},
	year = {2021},
	pages = {13},
	file = {Hilbig et al. - 2021 - An Empirical Study of Real-World WebAssembly Binar.pdf:C\:\\Users\\holge\\Zotero\\storage\\K84M3G7I\\Hilbig et al. - 2021 - An Empirical Study of Real-World WebAssembly Binar.pdf:application/pdf},
}


@article{musch_new_2019,
	title = {New {Kid} on the {Web}: {A} {Study} on the {Prevalence} of {WebAssembly} in the {Wild}},
	abstract = {WebAssembly, or Wasm for short, is a new, low-level language that allows for near-native execution performance and is supported by all major browsers as of today. In comparison to JavaScript it oﬀers faster transmission, parsing, and execution times. Up until now it has, however, been largely unclear what WebAssembly is used for in the wild. In this paper, we thus conduct the ﬁrst large-scale study on the Web. For this, we examine the prevalence of WebAssembly in the Alexa Top 1 million websites and ﬁnd that as many as 1 out of 600 sites execute Wasm code. Moreover, we perform several secondary analyses, including an evaluation of code characteristics and the assessment of a Wasm module’s ﬁeld of application. Based on this, we ﬁnd that over 50 \% of all sites using WebAssembly apply it for malicious deeds, such as mining and obfuscation.},
	language = {en},
	author = {Musch, Marius and Wressnegger, Christian and Johns, Martin and Rieck, Konrad},
	year = {2019},
	pages = {20},
	file = {Musch et al. - New Kid on the Web A Study on the Prevalence of W.pdf:C\:\\Users\\holge\\Zotero\\storage\\GVX3FYAT\\Musch et al. - New Kid on the Web A Study on the Prevalence of W.pdf:application/pdf},
}


@article{rossberg_bringing_2018,
	title = {Bringing the web up to speed with {WebAssembly}},
	volume = {61},
	issn = {0001-0782, 1557-7317},
	url = {https://dl.acm.org/doi/10.1145/3282510},
	doi = {10.1145/3282510},
	abstract = {The maturation of the Web platform has given rise to sophisticated Web applications such as 3D visualization, audio and video software, and games. With that, efficiency and security of code on the Web has become more important than ever. WebAssembly is a portable low-level bytecode that addresses these requirements by offering a compact representation, efficient validation and compilation, and safe execution with low to no overhead. It has recently been made available in all major browsers. Rather than committing to a specific programming model, WebAssembly is an abstraction over modern hardware, making it independent of language, hardware, and platform and applicable far beyond just the Web. WebAssembly is the first mainstream language that has been designed with a formal semantics from the start, finally utilizing formal methods that have matured in programming language research over the last four decades.},
	language = {en},
	number = {12},
	urldate = {2021-06-13},
	journal = {Communications of the ACM},
	author = {Rossberg, Andreas and Titzer, Ben L. and Haas, Andreas and Schuff, Derek L. and Gohman, Dan and Wagner, Luke and Zakai, Alon and Bastien, J. F. and Holman, Michael},
	month = nov,
	year = {2018},
	pages = {107--115},
	file = {Rossberg et al. - 2018 - Bringing the web up to speed with WebAssembly.pdf:C\:\\Users\\holge\\Zotero\\storage\\ZT6TNPU7\\Rossberg et al. - 2018 - Bringing the web up to speed with WebAssembly.pdf:application/pdf},
}


@article{cousot_abstract_2000,
	title = {Abstract {Interpretation}: {Achievements} and {Perspectives}},
	abstract = {Interpretation [3], [4] is a theory of discrete approximation which can be applied to the semantics of (speciﬁcation or programming) languages. Abstract Inter­ pretation formalizes the idea that a semantics can be more or less precise according to the considered observation level [1].},
	language = {en},
	author = {Cousot, Patrick},
	month = aug,
	year = {2000},
	pages = {7},
	file = {Cousot - Abstract Interpretation Achievements and Perspect.pdf:C\:\\Users\\holge\\Zotero\\storage\\AY6Q9Y2T\\Cousot - Abstract Interpretation Achievements and Perspect.pdf:application/pdf},
}


@inproceedings{shoshitaishvili_sok_2016,
	address = {San Jose, CA},
	title = {{SOK}: ({State} of) {The} {Art} of {War}: {Offensive} {Techniques} in {Binary} {Analysis}},
	isbn = {978-1-5090-0824-7},
	shorttitle = {{SOK}},
	url = {http://ieeexplore.ieee.org/document/7546500/},
	doi = {10.1109/SP.2016.17},
	abstract = {Finding and exploiting vulnerabilities in binary code is a challenging task. The lack of high-level, semantically rich information about data structures and control constructs makes the analysis of program properties harder to scale. However, the importance of binary analysis is on the rise. In many situations binary analysis is the only possible way to prove (or disprove) properties about the code that is actually executed. In this paper, we present a binary analysis framework that implements a number of analysis techniques that have been proposed in the past. We present a systematized implementation of these techniques, which allows other researchers to compose them and develop new approaches. In addition, the implementation of these techniques in a unifying framework allows for the direct comparison of these approaches and the identiﬁcation of their advantages and disadvantages. The evaluation included in this paper is performed using a recent dataset created by DARPA for evaluating the effectiveness of binary vulnerability analysis techniques.},
	language = {en},
	urldate = {2021-06-13},
	booktitle = {2016 {IEEE} {Symposium} on {Security} and {Privacy} ({SP})},
	publisher = {IEEE},
	author = {Shoshitaishvili, Yan and Wang, Ruoyu and Salls, Christopher and Stephens, Nick and Polino, Mario and Dutcher, Andrew and Grosen, John and Feng, Siji and Hauser, Christophe and Kruegel, Christopher and Vigna, Giovanni},
	month = may,
	year = {2016},
	pages = {138--157},
	file = {Shoshitaishvili et al. - 2016 - SOK (State of) The Art of War Offensive Techniqu.pdf:C\:\\Users\\holge\\Zotero\\storage\\UEVVDZ29\\Shoshitaishvili et al. - 2016 - SOK (State of) The Art of War Offensive Techniqu.pdf:application/pdf},
}


@article{li_fuzzing_2018,
	title = {Fuzzing: a survey},
	volume = {1},
	issn = {2523-3246},
	shorttitle = {Fuzzing},
	url = {https://cybersecurity.springeropen.com/articles/10.1186/s42400-018-0002-y},
	doi = {10.1186/s42400-018-0002-y},
	abstract = {Security vulnerability is one of the root causes of cyber-security threats. To discover vulnerabilities and fix them in advance, researchers have proposed several techniques, among which fuzzing is the most widely used one. In recent years, fuzzing solutions, like AFL, have made great improvements in vulnerability discovery. This paper presents a summary of the recent advances, analyzes how they improve the fuzzing process, and sheds light on future work in fuzzing. Firstly, we discuss the reason why fuzzing is popular, by comparing different commonly used vulnerability discovery techniques. Then we present an overview of fuzzing solutions, and discuss in detail one of the most popular type of fuzzing, i.e., coverage-based fuzzing. Then we present other techniques that could make fuzzing process smarter and more efficient. Finally, we show some applications of fuzzing, and discuss new trends of fuzzing and potential future directions.},
	language = {en},
	number = {1},
	urldate = {2021-06-14},
	journal = {Cybersecurity},
	author = {Li, Jun and Zhao, Bodong and Zhang, Chao},
	month = dec,
	year = {2018},
	pages = {6},
	file = {Li et al. - 2018 - Fuzzing a survey.pdf:C\:\\Users\\holge\\Zotero\\storage\\KQFI5U47\\Li et al. - 2018 - Fuzzing a survey.pdf:application/pdf},
}


@article{boudjema_vyper_2020,
	title = {{VYPER}: {Vulnerability} detection in binary code},
	volume = {3},
	issn = {2475-6725, 2475-6725},
	shorttitle = {{VYPER}},
	url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/spy2.100},
	doi = {10.1002/spy2.100},
	abstract = {This paper presents a method for exploitable vulnerabilities detection in binary code with almost no false positives. It is based on the concolic (a mix of concrete and symbolic) execution of software binary code and the annotation of sensitive memory zones of the corresponding program traces (represented in a formal manner). Three big families of vulnerabilities are considered (taint related, stack overflow, and heap overflow). Based on the angr framework as a supporting software VulnerabilitY detection based on dynamic behavioral PattErn Recognition was developed to demonstrate the viability of the method. Several test cases using custom code, Juliet test base and widely used public libraries were performed showing a high detection potential for exploitable vulnerabilities with a very low rate of false positives.},
	language = {en},
	number = {2},
	urldate = {2021-06-13},
	journal = {Security and Privacy},
	author = {Boudjema, El Habib and Verlan, Sergey and Mokdad, Lynda and Faure, Christèle},
	month = mar,
	year = {2020},
	file = {Boudjema et al. - 2020 - VYPER Vulnerability detection in binary code.pdf:C\:\\Users\\holge\\Zotero\\storage\\MP2HK6WP\\Boudjema et al. - 2020 - VYPER Vulnerability detection in binary code.pdf:application/pdf},
}

@article{li_locating_2019,
	title = {Locating {Vulnerability} in {Binaries} {Using} {Deep} {Neural} {Networks}},
	volume = {7},
	issn = {2169-3536},
	url = {https://ieeexplore.ieee.org/document/8843873/},
	doi = {10.1109/ACCESS.2019.2942043},
	abstract = {Binary fault localization is important for vulnerability analysis, but many current techniques face problems in locating vulnerability accurately and effectively, especially for real-world programs. In this paper, we propose a novel gradient-guided vulnerability locating method named DeepVL, which leverages deep neural networks to diagnose the root cause of weakness in binaries and provide guidance information for further analysis. DeepVL collects sufﬁcient amounts of crashed execution traces and normal execution traces as input of the constructed neural networks. Based on trained neural network, DeepVL calculates the gradient information for each basic block in traces and ﬁlter out the vulnerable basic blocks according to corresponding gradients. To demonstrate the applicability of DeepVL, we perform plenty of experiments on different datasets. According to the experimental results on Common Weakness Enumeration (CWE) dataset, DeepVL could locate different types of vulnerabilities accurately and effectively, with recall@10 reaching 96.9\% and precision@10 reaching 70.1\%. Additionally, the results on Cyber Grand Challenge (CGC) program and LibTIFF 4.0.10 show that DeepVL is capable of locating vulnerable basic blocks in large-scale programs. As a fault localization tool, DeepVL could greatly reduce the manual effort of ﬁnding vulnerabilities in binaries.},
	language = {en},
	urldate = {2021-06-13},
	journal = {IEEE Access},
	author = {Li, Runhao and Zhang, Chen and Feng, Chao and Zhang, Xing and Tang, Chaojing},
	year = {2019},
	pages = {134660--134676},
	file = {Li et al. - 2019 - Locating Vulnerability in Binaries Using Deep Neur.pdf:C\:\\Users\\holge\\Zotero\\storage\\DYHCNWRB\\Li et al. - 2019 - Locating Vulnerability in Binaries Using Deep Neur.pdf:application/pdf},
}


@article{lopes_discovering_2021,
	title = {Discovering {Vulnerabilities} in {WebAssembly} with {Code} {Property} {Graphs}},
	abstract = {WebAssembly is a new technology that allows web developers to run native C/C++ on a webpage with near-native performance and therefore much faster than typical JavaScript applications. Currently supported by the most popular browsers, WebAssembly brings implications for the web platform since it enables more complex client apps to run on the browser. The compact binary format, performance, and safety mechanisms present in the language led it to be used beyond the browser platform, being employed in the context of server-side runtimes, IoT platforms and edge computing. However, in spite of its beneﬁts, WebAssembly technology brings some security concerns attached. In particular, vulnerabilities from C and C++ such buﬀer overﬂows can be imported to WebAssembly. The goal of this project is to design and implement a new tool that can statically ﬁnd vulnerabilities in WebAssembly code. Our approach is to use code property graphs (CPGs), a program representation that has been successfully applied to the detection of vulnerabilities in high-level languages. We propose to adopt this representation into the realm of WebAssembly programs.},
	language = {en},
	author = {Lopes, Pedro Daniel Rogeiro},
	year = {2021},
	pages = {31},
	file = {Lopes - Discovering Vulnerabilities in WebAssembly with Co.pdf:C\:\\Users\\holge\\Zotero\\storage\\AVAFUJVN\\Lopes - Discovering Vulnerabilities in WebAssembly with Co.pdf:application/pdf},
}


@incollection{sun_new_2018,
	address = {Cham},
	title = {The {New} {Progress} in the {Research} of {Binary} {Vulnerability} {Analysis}},
	volume = {11064},
	isbn = {978-3-030-00008-0 978-3-030-00009-7},
	url = {http://link.springer.com/10.1007/978-3-030-00009-7_25},
	abstract = {Although vulnerability analysis based on source code has achieved a signiﬁcant progress, large numbers of software exist in binary code, research of binary vulnerability analysis is more important. This paper presented an overview of the ﬁeld of binary vulnerability analysis framework, classiﬁed typical vulnerability analysis technologies into intermediate language, taint analysis, symbolic execution, and fuzzing, classiﬁed current framework based on typical analysis technologies, summarized limitations of current framework and design a next generation automatic binary vulnerability analysis framework, and then we summarized the core principles, process, and limitations of each analysis technology in next generation frameworks, and discussed possible optimizations that could improved vulnerability analysis. This survey on binary vulnerability analysis can provide theoretical guidance for the development of the future binary analysis.},
	language = {en},
	urldate = {2021-06-13},
	booktitle = {Cloud {Computing} and {Security}},
	publisher = {Springer International Publishing},
	author = {Tan, Tiantian and Wang, Baosheng and Xu, Zhou and Tang, Yong},
	editor = {Sun, Xingming and Pan, Zhaoqing and Bertino, Elisa},
	year = {2018},
	doi = {10.1007/978-3-030-00009-7_25},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {265--276},
	file = {Tan et al. - 2018 - The New Progress in the Research of Binary Vulnera.pdf:C\:\\Users\\holge\\Zotero\\storage\\FNNLFAWM\\Tan et al. - 2018 - The New Progress in the Research of Binary Vulnera.pdf:application/pdf},
}



@article{lehmann_wasabi_2018,
	title = {Wasabi: {A} {Framework} for {Dynamically} {Analyzing} {WebAssembly}},
	abstract = {WebAssembly is the new low-level language for the web and has now been implemented in all major browsers since over a year. To ensure the security, performance, and correctness of future web applications, there is a strong need for dynamic analysis tools for WebAssembly. However, building such tools from scratch requires knowledge of low-level details of the language and its runtime environment.},
	language = {en},
	author = {Lehmann, Daniel and Pradel, Michael},
	year = {2018},
	pages = {14},
	file = {Lehmann und Pradel - Wasabi A Framework for Dynamically Analyzing WebA.pdf:C\:\\Users\\holge\\Zotero\\storage\\93T4KQPL\\Lehmann und Pradel - Wasabi A Framework for Dynamically Analyzing WebA.pdf:application/pdf},
}


@article{sun_poster_2021,
	title = {Poster: {Known} {Vulnerability} {Detection} for {WebAssembly} {Binaries}},
	language = {en},
	author = {Sun, Pengfei and Garcia, Luis and Han, Yi and Zonouz, Saman and Zhao, Yao},
	month = apr,
	year = {2021},
	pages = {2},
	file = {Sun et al. - Poster Known Vulnerability Detection for WebAssem.pdf:C\:\\Users\\holge\\Zotero\\storage\\KGQLA36U\\Sun et al. - Poster Known Vulnerability Detection for WebAssem.pdf:application/pdf},
}



@article{fu_taintassembly_2018,
	title = {{TaintAssembly}: {Taint}-{Based} {Information} {Flow} {Control} {Tracking} for {WebAssembly}},
	shorttitle = {{TaintAssembly}},
	url = {http://arxiv.org/abs/1802.01050},
	abstract = {WebAssembly (wasm) has recently emerged as a promisingly portable, size-efﬁcient, fast, and safe binary format for the web. As WebAssembly can interact freely with JavaScript libraries, this gives rise to a potential for undesirable behavior to occur. It is therefore important to be able to detect when this might happen. A way to do this is through taint tracking, where we follow the ﬂow of information by applying taint labels to data. In this paper, we describe TaintAssembly, a taint tracking engine for interpreted WebAssembly, that we have created by modifying the V8 JavaScript engine. We implement basic taint tracking functionality, taint in linear memory, and a probabilistic variant of taint. We then benchmark our TaintAssembly engine by incorporating it into a Chromium build and running it on custom test scripts and various real world WebAssembly applications. We ﬁnd that our modiﬁcations to the V8 engine do not incur signiﬁcant overhead with respect to vanilla V8’s interpreted WebAssembly, making TaintAssembly suitable for development and debugging.},
	language = {en},
	urldate = {2021-06-13},
	journal = {arXiv:1802.01050 [cs]},
	author = {Fu, William and Lin, Raymond and Inge, Daniel},
	month = feb,
	year = {2018},
	note = {arXiv: 1802.01050},
	keywords = {Computer Science - Cryptography and Security},
	file = {Fu et al. - 2018 - TaintAssembly Taint-Based Information Flow Contro.pdf:C\:\\Users\\holge\\Zotero\\storage\\QM85659M\\Fu et al. - 2018 - TaintAssembly Taint-Based Information Flow Contro.pdf:application/pdf},
}
